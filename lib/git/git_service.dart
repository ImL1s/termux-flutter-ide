import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../termux/ssh_service.dart';
import '../core/providers.dart';

/// Git Service
class GitService {
  final SSHService _ssh;

  GitService(this._ssh);

  Future<SSHExecResult> _exec(String cmd) async {
    if (!_ssh.isConnected) {
      await _ssh.connect();
    }
    // Using simple quote wrapping. For complex paths, maybe use valid escaping.
    // Assuming project paths generated by us are safe-ish.
    return await _ssh.executeWithDetails(cmd);
  }

  Future<bool> isGitRepository(String path) async {
    final result = await _exec(
      'cd "$path" && git rev-parse --is-inside-work-tree',
    );
    return result.success && result.stdout.trim() == 'true';
  }

  Future<String> getStatus(String path) async {
    final result = await _exec(
      'cd "$path" && git status --porcelain',
    );
    return result.success ? result.stdout : '';
  }

  Future<String> getCurrentBranch(String path) async {
    final result = await _exec(
      'cd "$path" && git rev-parse --abbrev-ref HEAD',
    );
    return result.success ? result.stdout.trim() : '';
  }

  Future<bool> stageFile(String path, String file) async {
    final result = await _exec(
      'cd "$path" && git add "$file"',
    );
    return result.success;
  }

  Future<bool> unstageFile(String path, String file) async {
    final result = await _exec(
      'cd "$path" && git restore --staged "$file"',
    );
    return result.success;
  }

  Future<bool> commit(String path, String message) async {
    // Escape double quotes in message
    final escapedMessage = message.replaceAll('"', '\\"');
    final result = await _exec(
      'cd "$path" && git commit -m "$escapedMessage"',
    );
    return result.success;
  }

  Future<SSHExecResult> push(String path) async {
    return await _exec('cd "$path" && git push');
  }

  Future<SSHExecResult> pull(String path) async {
    return await _exec('cd "$path" && git pull');
  }

  Future<String> diff(String path, String file) async {
    final result = await _exec(
      'cd "$path" && git diff "$file"',
    );
    return result.success ? result.stdout : '';
  }

  /// List all local branches
  Future<List<String>> listBranches(String path) async {
    final result = await _exec(
      'cd "$path" && git branch --format="%(refname:short)"',
    );
    if (!result.success) return [];

    return result.stdout
        .split('\n')
        .map((b) => b.trim())
        .where((b) => b.isNotEmpty)
        .toList();
  }

  /// Checkout to a branch
  Future<SSHExecResult> checkout(String path, String branch) async {
    return await _exec('cd "$path" && git checkout "$branch"');
  }

  /// Create and checkout a new branch
  Future<SSHExecResult> createBranch(String path, String branchName) async {
    return await _exec('cd "$path" && git checkout -b "$branchName"');
  }

  // Initialize new repo
  Future<bool> init(String path) async {
    final result = await _exec(
      'cd "$path" && git init',
    );
    return result.success;
  }

  /// Clone a repository from URL
  Future<String?> clone(String url, String targetDir) async {
    // Extract repo name from URL (e.g., user/repo.git -> repo)
    String repoName = url.split('/').last;
    if (repoName.endsWith('.git')) {
      repoName = repoName.substring(0, repoName.length - 4);
    }

    final clonePath = '$targetDir/$repoName';
    final result = await _exec(
      'cd "$targetDir" && git clone "$url"',
    );

    if (result.success) {
      return clonePath;
    }
    return null;
  }

  /// Get formatted git log for graph rendering
  Future<List<GitCommit>> getGitLog(String path) async {
    // Format: hash|parents|timestamp|message|refs|author
    final format = '%H|%P|%at|%s|%d|%an';
    final result = await _exec(
      'cd "$path" && git log --all --pretty=format:"$format" -n 100',
    );

    if (!result.success || result.stdout.isEmpty) {
      return [];
    }

    final commits = <GitCommit>[];
    for (final line in result.stdout.split('\n')) {
      if (line.trim().isEmpty) continue;
      final parts = line.split('|');
      if (parts.length < 6) continue;

      commits.add(GitCommit(
        hash: parts[0],
        parents: parts[1].split(' ').where((p) => p.isNotEmpty).toList(),
        timestamp: int.tryParse(parts[2]) ?? 0,
        message: parts[3],
        refs: parts[4].trim(),
        author: parts[5],
      ));
    }
    return commits;
  }
}

/// Git Service Provider
final gitServiceProvider = Provider<GitService>((ref) {
  final ssh = ref.watch(sshServiceProvider);
  return GitService(ssh);
});

/// Git Status Provider
final gitStatusProvider =
    FutureProvider.autoDispose<List<GitFileChange>>((ref) async {
  final path = ref.watch(projectPathProvider);
  if (path == null) return [];

  final service = ref.watch(gitServiceProvider);

  // Allow one connect attempt if not connected?
  // The service methods will auto-connect.
  // But isGitRepository needs to run.

  // We should debounce or catch error here?
  try {
    if (!await service.isGitRepository(path)) {
      return [];
    }
  } catch (e) {
    // SSH might be disconnected and connect failed
    return [];
  }

  final statusOutput = await service.getStatus(path);
  final changes = <GitFileChange>[];

  for (final line in statusOutput.split('\n')) {
    if (line.trim().isEmpty) continue;

    // Parse porcelain format: XY Path
    // X = staged status, Y = unstaged status
    if (line.length < 4) continue;

    final x = line[0];
    final y = line[1];
    final filePath = line.substring(3).trim();

    changes.add(GitFileChange(
      path: filePath,
      stagedStatus: x,
      unstagedStatus: y,
    ));
  }

  return changes;
});

class GitFileChange {
  final String path;
  final String stagedStatus;
  final String unstagedStatus;

  GitFileChange({
    required this.path,
    required this.stagedStatus,
    required this.unstagedStatus,
  });

  bool get isStaged => stagedStatus != ' ' && stagedStatus != '?';
  bool get isModified => unstagedStatus != ' ';
  bool get isUntracked => stagedStatus == '?' && unstagedStatus == '?';
}

class GitCommit {
  final String hash;
  final List<String> parents;
  final int timestamp;
  final String message;
  final String refs;
  final String author;

  GitCommit({
    required this.hash,
    required this.parents,
    required this.timestamp,
    required this.message,
    required this.refs,
    required this.author,
  });

  String get shortHash => hash.substring(0, 7);
}

final gitHistoryProvider =
    FutureProvider.autoDispose<List<GitCommit>>((ref) async {
  final path = ref.watch(projectPathProvider);
  if (path == null) return [];

  final service = ref.watch(gitServiceProvider);
  try {
    if (!await service.isGitRepository(path)) return [];
    return service.getGitLog(path);
  } catch (e) {
    return [];
  }
});

final gitBranchProvider = FutureProvider.autoDispose<String>((ref) async {
  final path = ref.watch(projectPathProvider);
  if (path == null) return '';
  final service = ref.watch(gitServiceProvider);
  return service.getCurrentBranch(path);
});

final gitBranchListProvider =
    FutureProvider.autoDispose<List<String>>((ref) async {
  final path = ref.watch(projectPathProvider);
  if (path == null) return [];
  final service = ref.watch(gitServiceProvider);
  try {
    if (!await service.isGitRepository(path)) return [];
    return service.listBranches(path);
  } catch (e) {
    return [];
  }
});
